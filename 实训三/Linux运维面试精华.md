[TOC]





# Linux运维面试精华

# 必背

## 1、什么是运维？什么是游戏运维？

1）运维是指大型组织已经建立好的网络软硬件的维护，就是要保证业务的上线与运作的正常，在他运转的过程中，对他进行维护，他集合了网络、系统、数据库、开发、安全、监控于一身的技术，运维又包括很多种，有DBA运维、网站运维、虚拟化运维、监控运维、游戏运维等等

2）游戏运维又有分工，分为开发运维、应用运维（业务运维）和系统运维

开发运维：是给应用运维开发运维工具和运维平台的
应用运维：是给业务上线、维护和做故障排除的，用开发运维开发出来的工具给业务上线、维护、做故障排查
系统运维：是给应用运维提供业务上的基础设施，比如：系统、网络、监控、硬件等等

总结：开发运维和系统运维给应用运维提供了“工具”和“基础设施”上的支撑

开发运维、应用运维和系统运维他们的工作是环环相扣的

## 2、在工作中，运维人员经常需要跟运营人员打交道，请问运营人员是做什么工作的？

游戏运营要做的一个事情除了协调工作以外，还需要与各平台沟通，做好开服的时间、开服数、用户导量、活动等计划

## 3、现在给你三百台服务器，你怎么对他们进行管理？

管理3百台服务器的方式：
1）设定跳板机，使用统一账号登录，便于安全与登录的考量。
2）使用salt、ansiable、puppet进行系统的统一调度与配置的统一管理。
3）建立简单的服务器的系统、配置、应用的cmdb信息管理。便于查阅每台服务器上的各种信息记录。

## **4、简述raid0 raid1 raid5 三种工作模式的工作原理及特点**

RAID，可以把硬盘整合成一个大磁盘，还可以在大磁盘上再分区，放数据
还有一个大功能，多块盘放在一起可以有冗余（备份）
RAID整合方式有很多，常用的：0 1 5 10

RAID 0，可以是一块盘和N个盘组合

其优点读写快，是RAID中最好的
缺点：没有冗余，一块坏了数据就全没有了

RAID 1，只能2块盘，盘的大小可以不一样，以小的为准

10G+10G只有10G，另一个做备份。它有100%的冗余，缺点：浪费资源，成本高

RAID 5 ，3块盘，容量计算10*（n-1）,损失一块盘

特点，读写性能一般，读还好一点，写不好

冗余从好到坏：RAID1 RAID10 RAID 5 RAID0

性能从好到坏：RAID0 RAID10 RAID5 RAID1

成本从低到高：RAID0 RAID5 RAID1 RAID10

 

单台服务器：很重要盘不多，系统盘，RAID1

数据库服务器：主库：RAID10 从库 RAID5RAID0（为了维护成本，RAID10）

WEB服务器，如果没有太多的数据的话，RAID5,RAID0（单盘）

有多台，监控、应用服务器，RAID0 RAID5

我们会根据数据的存储和访问的需求，去匹配对应的RAID级别

 

## **5、LVS、Nginx、HAproxy有什么区别？工作中你怎么选择？**

LVS：是基于四层的转发
HAproxy：是基于四层和七层的转发，是专业的代理服务器
Nginx：是WEB服务器，缓存服务器，又是反向代理服务器，可以做七层的转发

**区别**：LVS由于是基于四层的转发所以只能做端口的转发，而基于URL的、基于目录的这种转发LVS就做不了

**工作选择**：

HAproxy和Nginx由于可以做七层的转发，所以URL和目录的转发都可以做，在很大并发量的时候我们就要选择LVS，像中小型公司的话并发量没那么大，选择HAproxy或者Nginx足已，由于HAproxy由是专业的代理服务器，配置简单，所以中小型企业推荐使用HAproxy

## **6、Squid、Varinsh和Nginx有什么区别，工作中你怎么选择？**

Squid、Varinsh和Nginx都是代理服务器

什么是代理服务器：

能当替用户去访问公网，并且能把访问到的数据缓存到服务器本地，等用户下次再访问相同的资源的时候，代理服务器直接从本地回应给用户，当本地没有的时候，我代替你去访问公网，我接收你的请求，我先在我自已的本地缓存找，如果我本地缓存有，我直接从我本地的缓存里回复你，如果我在我本地没有找到你要访问的缓存的数据，那么代理服务器就会代替你去访问公网

**区别：**

1）Nginx本来是反向代理/web服务器，用了插件可以做做这个副业但是本身不支持特性挺多，只能缓存静态文件

2）从这些功能上。varnish和squid是专业的cache服务，而nginx这些是第三方模块完成

3）varnish本身的技术上优势要高于squid，它采用了可视化页面缓存技术

 

在内存的利用上，Varnish比Squid具有优势，性能要比Squid高。

还有强大的通过Varnish管理端口，可以使用正则表达式快速、批量地清除部分缓存

它是内存缓存，速度一流，但是内存缓存也限制了其容量，缓存页面和图片一般是挺好的

4）squid的优势在于完整的庞大的cache技术资料，和很多的应用生产环境

工作中选择：

要做cache服务的话，我们肯定是要选择专业的cache服务，优先选择squid或者varnish。

## **7、Tomcat和Resin有什么区别，工作中你怎么选择？**

区别：Tomcat用户数多，可参考文档多，Resin用户数少，可考虑文档少
最主要区别则是Tomcat是标准的java容器，不过性能方面比resin的要差一些
但稳定性和java程序的兼容性，应该是比resin的要好

工作中选择：现在大公司都是用resin，追求性能；而中小型公司都是用Tomcat，追求稳定和程序的兼容

## **8、什么是中间件？什么是jdk？**

中间件介绍：

中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源

中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯
是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口

但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递，通过中间件，应用程序可以工作于多平台或OS环境。

jdk：jdk是Java的开发工具包，它是一种用于构建在 Java 平台上发布的应用程序、applet 和组件的开发环境

## **9、讲述一下Tomcat8005、8009、8080三个端口的含义？**

8005==》 关闭时使用

8009==》 为AJP端口，即容器使用，如Apache能通过AJP协议访问Tomcat的8009端口

8080==》 一般应用使用

 

## **10、什么叫CDN？**

1.即内容分发网络

2.其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可就近取得所需的内容，提高用户访问网站的速度

 

## **11、什么叫网站灰度发布？**

灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式

AB test就是一种灰度发布方式，让一部用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度

## **12、简述DNS进行域名解析的过程？**

用户要访问www.baidu.com，会先找本机的host文件，再找本地设置的DNS服务器，如果也没有的话，就去网络中找根服务器，根服务器反馈结果，说只能提供一级域名服务器.cn，就去找一级域名服务器，一级域名服务器说只能提供二级域名服务器.com.cn,就去找二级域名服务器，二级域服务器只能提供三级域名服务器.baidu.com.cn，就去找三级域名服务器，三级域名服务器正好有这个网站www.baidu.com，然后发给请求的服务器，保存一份之后，再发给客户端

13、RabbitMQ是什么东西？

RabbitMQ也就是消息队列中间件，消息中间件是在消息的传息过程中保存消息的容器
消息中间件再将消息从它的源中到它的目标中标时充当中间人的作用
队列的主要目的是提供路由并保证消息的传递；如果发送消息时接收者不可用
消息队列不会保留消息，直到可以成功地传递为止，当然，消息队列保存消息也是有期限地

## **14、讲一下Keepalived的工作原理？**









## **15、讲述一下LVS三种模式的工作过程？**

LVS 有三种负载均衡的模式，分别是VS/NAT（nat 模式） VS/DR(路由模式) VS/TUN（隧道模式）

**一、NAT模式（VS-NAT）**

**原理**：就是把客户端发来的数据包的IP头的目的地址，在负载均衡器上换成其中一台RS的IP地址
并发至此RS来处理,RS处理完后把数据交给负载均衡器,负载均衡器再把数据包原IP地址改为自己的IP
将目的地址改为客户端IP地址即可期间,无论是进来的流量,还是出去的流量,都必须经过负载均衡器
**优点**：集群中的物理服务器可以使用任何支持TCP/IP操作系统，只有负载均衡器需要一个合法的IP地址
**缺点**：扩展性有限。当服务器节点（普通PC服务器）增长过多时,负载均衡器将成为整个系统的瓶颈
因为所有的请求包和应答包的流向都经过负载均衡器。当服务器节点过多时
大量的数据包都交汇在负载均衡器那，速度就会变慢！

**二、IP隧道模式（VS-TUN）**

**原理**：首先要知道，互联网上的大多Internet服务的请求包很短小，而应答包通常很大
那么隧道模式就是，把客户端发来的数据包，封装一个新的IP头标记(仅目的IP)发给RS
RS收到后,先把数据包的头解开,还原数据包,处理后,直接返回给客户端,不需要再经过
负载均衡器。注意,由于RS需要对负载均衡器发过来的数据包进行还原,所以说必须支持
IPTUNNEL协议，所以,在RS的内核中,必须编译支持IPTUNNEL这个选项
**优点**：负载均衡器只负责将请求包分发给后端节点服务器，而RS将应答包直接发给用户
所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量
这种方式，一台负载均衡器能够为很多RS进行分发。而且跑在公网上就能进行不同地域的分发。
**缺点**：隧道模式的RS节点需要合法IP，这种方式需要所有的服务器支持”IP Tunneling”
(IP Encapsulation)协议，服务器可能只局限在部分Linux系统上

**三、直接路由模式（VS-DR）**

**原理**：负载均衡器和RS都使用同一个IP对外服务但只有DR对ARP请求进行响应
所有RS对本身这个IP的ARP请求保持静默也就是说,网关会把对这个服务IP的请求全部定向给DR
而DR收到数据包后根据调度算法,找出对应的RS,把目的MAC地址改为RS的MAC（因为IP一致）
并将请求分发给这台RS这时RS收到这个数据包,处理完成之后，由于IP一致，可以直接将数据返给客户
则等于直接从客户端收到这个数据包无异,处理后直接返回给客户端
由于负载均衡器要对二层包头进行改换,所以负载均衡器和RS之间必须在一个广播域
也可以简单的理解为在同一台交换机上
**优点**：和TUN（隧道模式）一样，负载均衡器也只是分发请求，应答包通过单独的路由方法返回给客户端
与VS-TUN相比，VS-DR这种实现方式不需要隧道结构，因此可以使用大多数操作系统做为物理服务器。
**缺点**：（不能说缺点，只能说是不足）要求负载均衡器的网卡必须与物理网卡在一个物理段上。

## **16、mysql的innodb如何定位锁问题，mysql如何减少主从复制延迟？**

mysql的innodb如何定位锁问题:
在使用 show engine innodb status检查引擎状态时，发现了死锁问题
在5.5中，information_schema 库中增加了三个关于锁的表（MEMORY引擎）
innodb_trx         ## 当前运行的所有事务
innodb_locks     ## 当前出现的锁
innodb_lock_waits  ## 锁等待的对应关系

**mysql如何减少主从复制延迟:**

如果延迟比较大，就先确认以下几个因素：

1.从库硬件比主库差，导致复制延迟

2.主从复制单线程，如果主库写并发太大，来不及传送到从库就会导致延迟。

3.更高版本的mysql可以支持多线程复制

4.慢SQL语句过多

5.网络延迟

6.master负载，主库读写压力大，导致复制延迟，架构的前端要加buffer及缓存层

7.slave负载，一般的做法是，使用多台slave来分摊读请求，再从这些slave中取一台专用的服务器，只作为备份用，不进行其他任何操作.另外， 2个可以减少延迟的参数:–slave-net-timeout=seconds 单位为秒 默认设置为 3600秒

参数含义：当slave从主数据库读取log数据失败后，等待多久重新建立连接并获取数据

–master-connect-retry=seconds 单位为秒 默认设置为 60秒

参数含义：当重新建立主从连接时，如果连接建立失败，间隔多久后重试

通常配置以上2个参数可以减少网络问题导致的主从数据同步延迟

**MySQL数据库主从同步延迟解决方案**

最简单的减少slave同步延时的方案就是在架构上做优化，尽量让主库的DDL快速执行，还有就是主库是写，对数据安全性较高，比如sync_binlog=1，innodb_flush_log_at_trx_commit= 1 之类的设置，而slave则不需要这么高的数据安全，完全可以讲sync_binlog设置为0或者关闭binlog，innodb_flushlog也可以设置为0来提高sql的执行效率。另外就是使用比主库更好的硬件设备作为slave

## **17、如何重置mysql root密码？**

一、 在已知MYSQL数据库的ROOT用户密码的情况下，修改密码的方法：

1、 在SHELL环境下，使用mysqladmin命令设置：
      mysqladmin –u root –p password “新密码”   回车后要求输入旧密码

2、 在mysql>环境中,使用update命令，直接更新mysql库user表的数据：

​      Update  mysql.user  set  password=password(‘新密码’)  where  user=’root’;
​      flush   privileges;
​      注意：mysql语句要以分号”；”结束

3、 在mysql>环境中，使用grant命令，修改root用户的授权权限。

​      grant  all  on  *.*  to   root@’localhost’  identified  by  ‘新密码’；

二、 如查忘记了mysql数据库的ROOT用户的密码，又如何做呢？方法如下：

1、 关闭当前运行的mysqld服务程序：service  mysqld  stop（要先将mysqld添加为系统服务）
2、 使用mysqld_safe脚本以安全模式（不加载授权表）启动mysqld 服务
      /usr/local/mysql/bin/mysqld_safe  –skip-grant-table  &
3、 使用空密码的root用户登录数据库，重新设置ROOT用户的密码
     ＃mysql  -u   root
      Mysql> Update  mysql.user  set  password=password(‘新密码’)  where  user=’root’;
      Mysql> flush   privileges;

## **18、lvs/nginx/haproxy优缺点**

Nginx的优点是：
1、工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。

2、Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一，相反LVS对网络稳定性依赖比较大，这点本人深有体会；

3、Nginx安装和配置比较简单，测试起来比较方便，它基本能把错误用日志打印出来，LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。

4、可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。

5、Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。

6、Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器，LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。

7、Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可考虑用其作为反向代理加速器

8、Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有lighttpd了，不过lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃

9、Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多

 

**Nginx的缺点是：**

1、Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点
2、对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测
     不支持Session的直接保持，但能通过ip_hash来解决

LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)

**LVS的优点是**：

1、抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低

2、配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率

3、工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS/DR+Keepalived

4、无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会收到大流量的影响。

5、应用范围较广，因为LVS工作在4层，所以它几乎可对所有应用做负载均衡，包括http、数据库、在线聊天室等

**LVS的缺点是：**

1、软件本身不支持正则表达式处理，不能做动静分离
     而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在
2、如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。

**HAProxy的特点是：**

1、HAProxy也是支持虚拟主机的。

2、HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导，同时支持通过获取指定的url来检测后端服务器的状态

3、HAProxy跟LVS类似，本身就只是一款负载均衡软件，单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的

4、HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡

5、HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：

①roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；
② static-rr，表示根据权重，建议关注；
③leastconn，表示最少连接者先处理，建议关注；
④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似
    我们用其作为解决session问题的一种方法，建议关注；
⑤ri，表示根据请求的URI；
⑥rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parameter name；
⑦hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；
⑧rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。

## **19、mysql数据备份工具**

mysqldump工具，mysqldump是mysql自带的备份工具，目录在bin目录下面：/usr/local/mysql/bin/mysqldump，支持基于innodb的热备份，但是由于是逻辑备份，所以速度不是很快，适合备份数据比较小的场景，Mysqldump完全备份+二进制日志可以实现基于时间点的恢复。

**基于LVM快照备份**

在物理备份中，有基于文件系统的物理备份（LVM的快照），也可以直接用tar之类的命令对整个数据库目录
进行打包备份，但是这些只能进行泠备份，不同的存储引擎备份的也不一样，myisam自动备份到表级别
而innodb不开启独立表空间的话只能备份整个数据库。

**tar包备份**

percona提供的xtrabackup工具，支持innodb的物理热备份，支持完全备份，增量备份，而且速度非常快，支持innodb存储引起的数据在不同，数据库之间迁移，支持复制模式下的从机备份恢复备份恢复，为了让xtrabackup支持更多的功能扩展，可以设立独立表空间，打开 innodb_file_per_table功能，启用之后可以支持单独的表备份

## 20、keepalive工作原理和如何做健康检查及脑裂

Keepalived 高可用服务对之间的故障切换转移，是通过 VRRP (Virtual Router Redundancy Protocol ,虚拟路

由器冗余协议）来实现的。

在 Keepalived 服务正常工作时，主 Master 节点会不断地向备节点发送（多播的方式）心跳消息 ICMP，用以告诉备 Backup 节点自己还活看，当主 Master 节点发生故障时，就无法发送心跳消息，备节点也就因此无法继续检测到来自主 Master 节点的心跳了，于是调用自身的接管程序，接管主 Master 节点的 IP 资源及服务。而当主 Master节点恢复时，备 Backup 节点又会释放主节点故障时自身接管的 IP 资源及服务，恢复到原来的备用角色。

 

**VRRP 介绍：**

VRRP ,全 称 Virtual Router Redundancy Protocol ,中文名为虚拟路由冗余协议 ，VRRP 的出现就是为了解决

静态踣甶的单点故障问题，VRRP 是通过一种竞选机制来将路由的任务交给某台 VRRP 路由器的。

 **出现脑裂的原因**：

一般来说，裂脑的发生，有以下几种原因：

高可用服务器对之间心跳线链路发生故障，导致无法正常通信。

因心跳线坏了（包括断了，老化）。

因网卡及相关驱动坏了，ip 配置及冲突问题（网卡直连）。

因心跳线间连接的设备故障（网卡及交换机）。

因仲裁的机器出问题（采用仲裁的方案）。

高可用服务器上开启了 iptables 防火墙阻挡了心跳消息传输。

高可用服务器上心跳网卡地址等信息配置不正确，导致发送心跳失败。

其他服务配置不当等原因，如心跳方式不同，心跳广插冲突、软件 Bug 等。

Keepalived 配置里 VRRP 实例如果 virtual_router_id 两端参数配置不一致也会导致裂脑问题发生。

 

**如何解决脑裂：**

① 同时使用串行电缆和以太网电缆连接，同时用两条心跳线路，这样一条线路坏了，另一个还是好的，依然能传

送心跳消息。

② 当检测到裂脑时强行关闭一个心跳节点（这个功能需特殊设备支持，如 Stonith、feyce）。相当于备节点接收

不到心跳消患，通过单独的线路发送关机命令关闭主节点的电源。

③ 做好对裂脑的监控报警（如邮件及手机短信等或值班）.在问题发生时人为第一时间介入仲裁，降低损失。

管理员可以通过手机回复对应数字或简单的字符串操作返回给服务器.让服务器根据指令自动处理相应故障这样解

决故障的时间更短。



**keepalived主要有三个模块**，分别是core、check和vrrp。core模块为keepalived的核心，负责主进程的启动、维护及全局配置文件的加载和解析。check负责健康检查，包括常见的各种检查方式，vrrp模块是来实现VRRP协议的

 

**Keepalived健康检查方式配置**

```
HTTP_GET|SSL_GET
HTTP_GET | SSL_GET
{
url {
path /# HTTP/SSL 检查的url可以是多个
digest  # HTTP/SSL 检查后的摘要信息用工具genhash生成
status_code 200# HTTP/SSL 检查返回的状态码
}
connect_port 80 # 连接端口
bindtoconnect_timeout 3 # 连接超时时间
nb_get_retry 3 # 重连次数
delay_before_retry 2 #连接间隔时间
}
```

 

 

## 21、统计ip访问情况，要求分析nginx访问日志，找出访问页面数量在前十位的ip

```
cat access.log | awk '{print $1}' | uniq -c | sort -rn | head -10
```

## 22、使用tcpdump监听主机为192.168.1.1，tcp端口为80的数据，同时将输出结果保存输出到tcpdump.log

```shell
tcpdump ‘host 192.168.1.1 and port 80’ > tcpdump.log
```

## 23、如何将本地80 端口的请求转发到8080 端口，当前主机IP 为192.168.2.1

```shell
iptables -A PREROUTING -d 192.168.2.1 -p tcp -m tcp -dport 80 -j DNAT-to-destination 192.168.2.1:8080
```

## 24、简述raid0 raid1 raid5 三种工作模式的工作原理及特点

**raid0 （条带卷）：**

需要几块硬盘 至少是一块硬盘，可以把所有硬盘的容量都叠加在一起； 拥有最高的读写速度，磁盘空间没有被浪费但是只要其中一块硬盘坏了，数据就全丢了。

 

**raid1（镜像卷）：**

只能是两块硬盘，读的速度相当于一块盘的速度，写的速度慢了一半，因为写的时候，一边正常写入，一边备份。磁盘空间被浪费了一半XXIV可以损坏一块盘

 

**raid5（奇偶校验卷）：**

至少需要 3 块盘及以上，读的速度快，写得速度慢，因为每次写入之后，都需要校验（奇偶校验）。损失一块盘的容量。

最多可以损坏一块。（还有一个热备盘，什么也不干，作为预备盘。）

 

**raid6：**

最少 4 块盘，5 块盘也可以，损失 2 块盘，不管硬盘多少，只损失两块盘容量。

 

**raid10：**

raid0 与 raid1 的组合：

至少需要 4 块硬盘，磁盘的数量必须是偶数（因为 raid1 必须是两块盘才能组合），读写速度都很快，损失了一半的容量，不管有多少盘，最多可以损坏两块盘，不支持虚拟磁盘。

 

1. raid0：追求性能，不需要保证数据的安全 mysql slave 数据库从库（数据库的小弟），集群的节

点。

2. raid1：安全性，对性能要求不高，对数据安全性高（有冗余）成本比较高。

3. raid5：对于性能要求不高 用户并发比较小

4. raid10：价格贵、性能好、安全性高、一般是用于数据库的主库。



## 25、你对现在运维工程师的理解和以及对其工作的认识

运维工程师在公司当中责任重大，需要保证时刻为公司及客户提供最高、最快、最稳定、最安全的服务
运维工程师的一个小小的失误，很有可能会对公司及客户造成重大损失
因此运维工程师的工作需要严谨及富有创新精神

## 26、实时抓取并显示当前系统中tcp 80端口的网络数据信息，请写出完整操作命令

```
tcpdump -nn tcp port 80
```

## 27、服务器开不了机怎么解决一步步的排查

A、造成服务器故障的原因可能有以下几点：

1.服务器电源有问题

2.服务器系统文件丢失，硬件问题，散热不良造成蓝屏和死机

3.服务器网络参数配置有误，物理链路原因等 

B、如何排查服务器故障的处理步骤如下：

![1585298560818](assets/1585298560818.png) 

## 28、Linux系统中病毒怎么解决

1）最简单有效的方法就是重装系统
2）要查的话就是找到病毒文件然后删除
中毒之后一般机器cpu、内存使用率会比较高，机器向外发包等异常情况，排查方法简单介绍下，top 命令找到cpu使用率最高的进程，一般病毒文件命名都比较乱，可以用 ps aux 找到病毒文件位置，rm -f  命令删除病毒文件，检查计划任务、开机启动项和病毒文件目录有无其他可以文件等

3）由于即使删除病毒文件不排除有潜伏病毒，所以最好是把机器备份数据之后重装一下

## 29、发现一个病毒文件你删了他又自动创建怎么解决

公司的内网某台linux服务器流量莫名其妙的剧增,用iftop查看有连接外网的情况
针对这种情况一般重点查看netstat连接的外网ip和端口。用lsof -p pid可以查看到具体是那些进程，哪些文件，经查勘发现/root下有相关的配置conf.n hhe两个可疑文件，rm -rf后不到一分钟就自动生成了，由此推断是某个母进程产生的这些文件。所以找到母进程就是找到罪魁祸首

查杀病毒最好断掉外网访问，还好是内网服务器，可以通过内网访问

断了内网，病毒就失去外联的能力，杀掉它就容易的多，怎么找到呢，找了半天也没有看到蛛丝马迹，没办法只有ps axu一个个排查，方法是查看可以的用户和和系统相似而又不是的冒牌货，果然，看到了如下进程可疑，看不到图片就是/usr/bin/.sshd，于是我杀掉所有.sshd相关的进程，然后直接删掉.sshd这个可执行文件，然后才删掉了文章开头提到的自动复活的文件

总结一下，遇到这种问题，如果不是太严重，尽量不要重装系统

一般就是先断外网，然后利用iftop,ps,netstat,chattr,lsof,pstree这些工具顺藤摸瓜
一般都能找到元凶。但是如果遇到诸如此类的问题
/boot/efi/EFI/redhat/grub.efi: Heuristics.Broken.Executable FOUND，个人觉得就要重装系统了

## 30、说说TCP/IP的七层模型

应用层 (Application)：网络服务与最终用户的一个接口。
协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP

表示层（Presentation Layer）：数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）
格式有，JPEG、ASCll、DECOIC、加密格式等

会话层（Session Layer）：建立、管理、终止会话。（在五层模型里面已经合并到了应用层）
对应主机进程，指本地主机与远程主机正在进行的会话

传输层 (Transport)：定义传输数据的协议端口号，以及流控和差错校验。
协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层

网络层 (Network)：进行逻辑地址寻址，实现不同网络之间的路径选择。
协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP

数据链路层 (Link)：建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）
将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正

物理层（Physical Layer）：是计算机网络OSI模型中最低的一层

物理层规定:为传输数据所需要的物理链路创建、维持、拆除
而提供具有机械的，电子的，功能的和规范的特性

简单的说，物理层确保原始的数据可在各种物理媒体上传输。局域网与广域网皆属第1、2层

物理层是OSI的第一层，它虽然处于最底层，却是整个开放系统的基础
物理层为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境
如果您想要用尽量少的词来记住这个第一层，那就是“信号和介质”

 ![img](assets/clipboard.png)

## 31、你常用的Nginx模块，用来做什么

```
rewrite模块，实现重写功能
access模块：来源控制
ssl模块：安全加密
ngx_http_gzip_module：网络传输压缩模块
ngx_http_proxy_module ：模块实现代理
ngx_http_upstream_module ：模块实现定义后端服务器列表
ngx_cache_purge ：实现缓存清除功能
```



## 32、请列出你了解的web服务器负载架构

```
Nginx
Haproxy
Keepalived
LVS
```

## 33、查看http的并发请求数与其TCP连接状态

```
netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’
```

还有ulimit -n 查看linux系统打开最大的文件描述符，这里默认1024
不修改这里web服务器修改再大也没用，若要用就修改很几个办法，这里说其中一个：
修改/etc/security/limits.conf

- soft nofile 10240

- hard nofile 10240

  重启后生效

## 34、用tcpdump嗅探80端口的访问看看谁最高

```shell
tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F”.” ‘{print $1″.”$2″.”$3″.”$4}’| sort | uniq -c | sort -nr |head -20
```

35、写一个脚本，实现判断192.168.1.0/24网络里，当前在线的IP有哪些，能ping通则认为在线

> 注意：此脚本中涉及到了wait关键字和&符号，实现shell脚本多进程执行

```shell
for ip in seq 1 255
do
{
	ping -c 1 192.168.1.$ip > /dev/null 2>&1
	if [ $? -eq 0 ]; then
		echo 192.168.1.$ip UP
	else
		echo 192.168.1.$ip DOWN
	fi
}&
done
wait
```

## 36、已知 apache 服务的访问日志按天记录在服务器本地目录/app/logs 下，由于磁盘空间紧张现在要求只能保留最近 7 天的访问日志！请问如何解决？请给出解决办法或配置或处理命令

```shell
创建文件脚本：
for n in seq 14
do        
	date -s “11/0$n/14”
	touch access_www_(date +%F).log
done
解决方法：
-rw-r–r–. 1 root root 0 Jan  1 00:00 access_www_2015-01-01.log
-rw-r–r–. 1 root root 0 Jan  2 00:00 access_www_2015-01-02.log
-rw-r–r–. 1 root root 0 Jan  3 00:00 access_www_2015-01-03.log
-rw-r–r–. 1 root root 0 Jan  4 00:00 access_www_2015-01-04.log
-rw-r–r–. 1 root root 0 Jan  5 00:00 access_www_2015-01-05.log
-rw-r–r–. 1 root root 0 Jan  6 00:00 access_www_2015-01-06.log
-rw-r–r–. 1 root root 0 Jan  7 00:00 access_www_2015-01-07.log
-rw-r–r–. 1 root root 0 Jan  8 00:00 access_www_2015-01-08.log
-rw-r–r–. 1 root root 0 Jan  9 00:00 access_www_2015-01-09.log
-rw-r–r–. 1 root root 0 Jan 10 00:00 access_www_2015-01-10.log
-rw-r–r–. 1 root root 0 Jan 11 00:00 access_www_2015-01-11.log
-rw-r–r–. 1 root root 0 Jan 12 00:00 access_www_2015-01-12.log
-rw-r–r–. 1 root root 0 Jan 13 00:00 access_www_2015-01-13.log
-rw-r–r–. 1 root root 0 Jan 14 00:00 access_www_2015-01-14.log

也可以使用-exec rm -f {} ;进行删除
-rw-r–r–. 1 root root 0 Jan  7 00:00 access_www_2015-01-07.log
-rw-r–r–. 1 root root 0 Jan  8 00:00 access_www_2015-01-08.log
-rw-r–r–. 1 root root 0 Jan  9 00:00 access_www_2015-01-09.log
-rw-r–r–. 1 root root 0 Jan 10 00:00 access_www_2015-01-10.log
-rw-r–r–. 1 root root 0 Jan 11 00:00 access_www_2015-01-11.log
-rw-r–r–. 1 root root 0 Jan 12 00:00 access_www_2015-01-12.log
-rw-r–r–. 1 root root 0 Jan 13 00:00 access_www_2015-01-13.log
-rw-r–r–. 1 root root 0 Jan 14 00:00 access_www_2015-01-14.log
或者
find /app/logs -type f  -mtime +7 -name '*.log'|xargs rm -f
```

## 37、如何优化 Linux系统（可以不说太具体）？

```
不用root，添加普通用户，通过sudo授权管理
更改默认的远程连接SSH服务端口及禁止root用户远程连接
定时自动更新服务器时间
配置国内yum源
关闭selinux及iptables（iptables工作场景如果有外网IP一定要打开，高并发除外）
调整文件描述符的数量
精简开机启动服务（crond rsyslog network sshd）
内核参数优化（/etc/sysctl.conf）
更改字符集，支持中文，但建议还是用英文字符集，防止乱码
锁定关键系统文件
清空/etc/issue，去除系统及内核版本登录前的屏幕显示
```



## 38、请执行命令取出 linux 中 eth0 的 IP 地址(请用 cut，有能力者也可分别用 awk,sed 命令答)

```shell
cut方法1：ifconfig eth0|sed -n ‘2p’|cut -d “:” -f2|cut -d ” ” -f1192.168.20.130
awk方法2：ifconfig eth0|awk ‘NR==2’|awk -F “:” ‘{print $2}’|awk ‘{print $1}’192.168.20.130
awk多分隔符方法3：ifconfig eth0|awk ‘NR==2’|awk -F “[: ]+” ‘{print $4}’192.168.20.130
sed方法4：ifconfig eth0|sed -n ‘/inet addr/p’|sed -r ‘s#^.ddr:(.)Bc.*$##g’192.168.20.130
```



## 40、每天晚上 12 点，打包站点目录/var/www/html 备份到/data 目录下（最好每次备份按时间生成不同的备份包）

```shell
$ cat a.sh
#!/bin/bash
cd /var/www/ && /bin/tar zcf /data/html-date +%m-%d%H.tar.gz html/

$ crontab –e
00 00 * * * /bin/sh /root/a.sh
```

## 41、DNS 原理

相信大家可能知道 windows 或者 linux 系统层面的/etc/hosts 文件是：IP 地址与域名的对应关系。

我们一般访问网站的步骤：

打开网页-------输入网址 www.sb.com-----查看本地的 DNS 库是否存在该网站域名与对应 ip 地址的对应关系

接下来分为两种情况：

① 本地存在该网站域名相对应的 IP 地址，然后我们直接根据本地缓存的 DNS 进行解析，然后访问

该域名对应的 IP 地址，然后进行 TCP 的三次握手,进行与网站的连接，当然我们访问网站完毕之

后，我们又进行了四次挥手，然后断开连接。（后面详细解释 TCP 的三次握手与四次挥手） 

② 本地不存在该网站域名与 IP 地址的对应关系，然后我们本地的 DNS 系统，也就是 LDNS（简称

local DNS）；开始从 DNS 系统的根进行请求对 www.sb.com 域名的解析，并且针对 DNS 系统的

各个阶层进行查找，进行一级一级的查找，最终会找到 www.sb.com 这个域名，当然 DNS 系统里

这个域名的进行授权的 DNS 服务器正是我们企业购买的 DNS 服务器，反之，没有该域名相应的

解析授权的 DNS 服务器，也就表明该网站没有搭建成功。

 

总结： 

进行本地 DNS 查找以及授权 DNS 服务器的查找，获得 IP 地址，并且加载本地 DNS 的缓存 

进行建立 TCP 连接的过程（三次握手），发送 http 报文以及请求报文的细节，web 服务器的响应并且处理客户端的 

请求，关闭 TCP 连接（四次挥手）； 

 

## 41、http 常识及常见状态码

**http 请求方法**

GET 客户端的=请求指定资源信息，服务器返回指定资源

HEAD 只请求响应报文中的 HTTP 首部

POST 将客户端的数据提交到服务器

PUT 用从客户端向服务器传送的数据取代指定文档的文档内容

DELETE 请求服务器删除 request-URI 所标识的资源

MOVE 请求服务器将指定的页面移动至另一个网络地址

 

**http 状态码**

http 状态码是用来表示 web 服务器响应 http 请求状态的数字代码（不同的数字代表不同的含义）

一般数字码分为：

100~199 用于客户端的相应的某些动作

200~299 用于表示成功（其中的 200 最常见）

300~399 用于已经移动的文件，并且常被包括在定位头信息中指定新的地址信息（301 永久跳转）

400~499 用于指出客户端的错误（403 禁止访问、404 页面找不到）

500~599 用于服务器内部的错误（500 服务器的内部错误、502 坏的网关、504 网关超时）

![HTTP相应状态码](assets/HTTP相应状态码.png)



 

## 43、TCP 的三次握手与四次挥手原理

 **三次握手**

![1585299113983](assets/1585299113983.png)

**CLOSED 关闭状态：** 

为建立建立连接之前的起始点，在连接超时或者连接关闭的时候进入此状态，但是这并不是一个真正的状态，而是

这个状态图的假想起点和终点（便于我们思考与理解）。

**LISTEN 监听状态：**

服务器 server 端等待连接的状态。服务器经过 socket，bind，listen 函数之后进入此状态，开始监听客户端发

过来的连接请求。此称为应用程序被动打开（等待客户端的连接请求）。

**SYN_SENT 状态：**

第一次握手发生阶段，客户端发起连接。客户端调用 connect，发送 SYN 给服务器端，然后客户端进入 SYN_SENT状态，等待服务端的确认（三次握手中的第二个报文）。如果服务器端不能连接，则客户端直接进入 CLOSED 状态。 

**SYN_RCVD 状态：**

第二次握手发生阶段，这里是服务器端接收到了客户端的 SYN 请求，此时服务端由 LISTEN 进入 SYN_RCVD 状态，同时服务器端回应一个 ACK，然后再发送一个 SYN 即 SYN+ACK 给客户端。

状态图中还描绘了这样一种情况，当客户端在发送 SYN 的同时也收到服务器端的 SYN 请求，即两个同时发起连接请求，那么客户端就会从 SYN_SENT 转换到 SYN_REVD 状态。

**ESTABLISHED 状态：**

第三次握手发生阶段，客户端接收到服务器端的 ACK 包（ACK，SYN）之后，也会发送一个 ACK 确认包，客户端进入 ESTABLISHED 状态，表明客户端这边已经准备好，但 TCP 需要两端都准备好才可以进行数据传输。服务器端收到客户端的 ACK 之后会从 SYN_RCVD 状态转移到 ESTABLISHED 状态，表明服务器端也准备好进行数据传输了。 

**总结：**

客户端和服务器端都变为 ESTABLISHED 状态，就可以进行数据的传输了；当然 ESTABLISHED 也可以说是一个数据传送状态。

**四次挥手**

![1585299158926](assets/1585299158926.png)

**FIN_WAIT_1 状态：**

第一次挥手 主动关闭的一方（执行主动关闭的一方既可以是客户端，也可以是服务器端，我们这里以客户端执行主动关闭为例子），终止连接时，发送 FIN 给对方，然后等待对方返回 ACK 。第一次挥手客户端就进入 fin_wait_1状态。

**CLOSE_WAIT 状态：**

接收到 FIN 之后，被动关闭的一方进入 close_wait 状态。进入该状态的具体动作是接收到客户端发来的 FIN，同时服务端对客户端发送 ACK。 CLOSE_WAIT 状态：可以理解为被动关闭的一方此时正在等待上层应用程序发出关闭连接指令。TCP 关闭是全双工过程，这里客户端执行了主动关闭，被动方服务器端接收到 FIN 后也需要调用 close 关闭，这个 CLOSE_WAIT 就是处于这个状态，等待关闭的请求方发送 FIN，发送了 FIN 则进入 LAST_ACK 状态。

**FIN_WAIT_2 状态：**

主动端（这里是客户端）先执行主动关闭发送 FIN，然后接收到被动方（这里是服务端）返回的 ACK 后进入此状态。

**LAST_ACK 状态：**

被动方（服务器端）发起关闭请求，发送 FIN 给对方，进入此状态，同时在接收到 ACK 时进入 CLOSED 状态。

**CLOSING 状态：**

两边同时发起关闭请求时（即主动方发送 FIN，等待被动方返回 ACK，同时被动方也发送了 FIN；主动方接收到了FIN 之后，发送 ACK 给被动方），主动方会由 FIN_WAIT_1 进入此状态，等待被动方返回 ACK。

**TIME_WAIT 状态：**

从状态变迁图会看到，四次挥手操作最后都会经过这样一个状态然后进入 CLOSED 状态。共有三个状态会进入该状态

**由 CLOSEING 状态进入：**

同时发起关闭情况下，当主动端接收到 ACK 后，进入此状态，实际上这里的同时是这样的情况：客户端发起关闭请求，发送 FIN 之后等待服务器端回应 ACK，但此时服务器端同时也发起关闭请求，也发送了 FIN，并且被客户端先于 ACK 接收到。

**由 FIN_WAIT_1 进入：**

发起关闭后，发送了 FIN，等待 ACK 的时候，正好被动方（服务器端）也发起关闭请求，发送了 FIN，这时客户端接收到了先前 ACK，也收到了对方的 FIN，然后发送 ACK（对对方 FIN 的回应），与 CLOSING 进入的状态不同的是接收到 FIN 和 ACK 的先后顺序。

**由 FIN_WAIT_2 进入：**

这是不同时的情况，主动方在完成自身发起的主动关闭请求后，接收到了对方发送过来的 FIN，然后回应 ACK。

## 44、TCP 十一种状态转移总结

![1585299339581](assets/1585299339581.png)

## 45、MySQL 主从同步原理

mysql 主从复制用途
实时灾备，用于故障切换
读写分离，提供查询服务
备份，避免影响业务

主从部署必要条件
主库开启 binlog 日志（设置 log-bin 参数）
主从 server-id 不同
从库服务器能连通主库

主从复制原理图：

![1585299402335](assets/1585299402335.png)

**该架构存在的问题：**

主库的宕机可能存在数据的丢失；当然从库也可能宕机，我们可以部署双从；

从库只有一个 SQL 线程，当用户的操作过多时，主库生成大量的 bin-log 二进制日志，从库可能忙不过来；

 

**数据库高可用介绍：**

我们使用的是 MHA 软件。。。

MHA 可以运行在每台 MySQL 服务器上，MHA 会定时探测集群中的 master 节点，当 master 出现故障时，它可以自动将最新数据的 slave 提升为新的 master，然后将所有其他的 slave 重新指向新的 master。整个故障转移过程对应用程序完全透明。

 

**MHA 的缺点：**

在 MHA 自动故障切换过程中，MHA 试图从宕机的主服务器上保存二进制日志，最大程度的保证数据的不丢失，但这并不总是可行的。例如，如果主服务器硬件故障或无法通过 ssh 访问，MHA 没法保存二进制日志，只进行故障转移而丢失了最新的数据。



## **46、文件删除的原理**

**删除文件但是该文件还被应用程序的调用的情况：**

对于删除命令 rm 而言，实际就是减少磁盘引用计数 i_nlink。这里就会有一个问题，如果一个文件正在被某个进程调用，而用户却执行 rm 操作把文件删除了，那么会出现什么结果呢？当用户执行 rm 操作删除文件后，再执行ls 或者其他文件管理命令，无法再找到这个文件了，但是调用这个删除的文件的进程却在继续正常执行，依然能够从文件中正确的读取及写入内容。也就是说，还需要解除该进程的对该文件的调用才行。

 

**当文件没有被调用时，执行了 rm 操作删除文件后是否还可以找回被删的文件呢？**

rm 操作只是将文件的 i_nlink 减少了，或者说置 0 了，实际就是将文件名到 inode 的链接删除了，此时，并没有删除文件的实体即（block 数据块），此时，如果及时停止机器工作，数据是可以找回的；如果此时继续写入数据，那么当新数据就可能会被分配到被删除的数据的 block 数据块，此时，文件就会被真正的回收了。

 

**如何删除文件：**

1.硬链接数为 0 与这个文件有关的所有硬链接都被删除。（使用的是 rm 命令）

2.进程调用数为 0 没有人在使用这个文件。（使用的是 lsof）

没有被彻底删除-硬链接数为 0,进程调用数不为零

解答:文件删除（硬链接）但是这个文件还有进程在调用，这个文件还没有被完全删除。最总导致磁

盘空间满了。硬链接数为零，进程调用数不为零，导致磁盘空间满了。



## 47、Linx 的运行级别

Linux 系统有 7 个运行级别(runlevel)

运行级别 0：系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动

运行级别 1：单用户工作状态，root 权限，用于系统维护，禁止远程登陆

运行级别 2：多用户状态(没有 NFS)

运行级别 3：完全的多用户状态(有 NFS)，登陆后进入控制台命令行模式

运行级别 4：系统未使用，保留

运行级别 5：X11 控制台，登陆后进入图形 GUI 模式

运行级别 6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动



## 48、Linux 开机启动流程

![1585358785644](assets/1585358785644.png)

```
① 打开电源 
② Bios 各个硬件的检查（不同的声响代表不同的含义） 
③ 硬盘的 MBR 引导 
④ GRUB 菜单，也就是选择需要加载的内核（不同的内核也就是不同的操作系统） 
⑤ 加载内核 
⑥ 启动第一个进程 init 进程 
⑦ 读取/etc/inittab 配置文件 
⑧ 执行/etc/rc.d/rc.sysinit 脚本 
⑨ 执行/etc/rc.d/rc 脚本（根据不同的运行级别选择开机自启动的软件） 
⑩ 启动 mingetty 进程（进入系统的登录界面） 
```



## 49、nginx和Apache的特点

**Apache 软件特点**

(1) Apache2.2 版本非常稳定强大，Apache2.4 版本性能更强

(2) Prefork 模式取消了进程创建开销，性能很高

(3) 处理动态业务数据时，因关联到后端的引擎和数据库，瓶颈不在 Apache 上

(4) 高并发时消耗系统资源相对多一些

(5) 基于传统的 select 模型，高并发能力有限

(6) 支持扩展库，可通过 DSO、apxs 方法编译安装额外的插件功能，不需要重新编译 Apache

(7) 功能多，更稳定，更安全，插件也多

(8) 市场份额在逐渐递减

 

**nginx 软件的特点**

支持高并发：能支持几万并发连接（特别是静态小文件业务环境）

资源消耗少：在 3 万并发连接下，开启 10 个 Nginx 线程消耗的内存不到 200MB、进程占用系统资源比较低

不支持类似 Apache 的 DSO 模式，扩展库必须编译进主程序（缺点）

支持 web、反向 proxy、cache 三大重点功能，并且都很优秀

可以做 HTTP 反向代理及加速缓存、即负载均衡功能（4 层以及 7 层），内置对 RS(real server)节点服务器健康检

查功能，这相当于专业的 Haproxy 软件或 LVS(4 层)的功能

具备 Squid 等专业缓存软件等的缓存功能（memcache/redis）

支持异步网络 I/O 事件模型 epoll (Linux 2.6+)

 

**nginx 总体性能为什么比 Apache 高**

Nginx 使用最新的 epoll(Linux2.6 内核)和 Kqueue(freebsd)异步网络 1O 模型

Apache 使用的是传统的 select 模型。

目前 Linux 下能够承受高并发访问的 Squid、Memcached 软件采用的都是 epoll 模型

 

**Apache select 和 nginx epoll 的技术对比**

| **指标**     | **select**                                                   | **epoll**                        |
| ------------ | ------------------------------------------------------------ | -------------------------------- |
| 性能         | 随着连接数的增加性能急剧下降，处理成千上万连接数性能很差     | 随着连接数的增加性能基本上没有下 |
| 连接数       | 连接数有限制，处理的最大连接数不 超过 1024，如果要处理的连接数超 过1024个，则需要修改FD_SETSIZE 宏，并重新编译 | 连接数无限制                     |
| 内在处理机制 | 线性轮询                                                     | 回调 callback                    |
| 开发复杂性低 | 低                                                           | 中                               |

 

**nginx 软件有哪些应用**

1）作为 Web 服务软件

2）反向代理或负载均衡服务

3）前端业务数据缓存服务（扩展 redis 缓存知识后）

 

 

**不同的业务选择的软件**

**静态业务**

若是高并发场景，尽量采用 Nginx 或 Lighttpd,二者首选 Nginx。

 

**动态业务**

理论上采用 Nginx 和 Apache 均可，建议选择 Nginx,为了避免相同业务的服务软件多样化，增加额外维护成本。动态业务可以由 Nginx 兼做前端代理，再根据页面元素的类型或目录，转发到后端相应的服务器处理进程。

 

**既有动态业务又有静态业务**

采用 Nginx

 

## 50、nginx日志管理与切割

**1、nginx日志管理**

**nginx日志描述**

通过访问日志，你可以得到用户地域来源、跳转来源、使用终端、某个URL访问量等相关信息；通过错误日志，你可以得到系统某个服务或server的性能瓶颈等。因此，将日志好好利用，你可以得到很多有价值的信息。

**Nginx日志格式**

打开nginx.conf配置文件：`vim /usr/local/nginx/conf/nginx.conf`

日志部分内容：

```
#access_log  logs/access.log  main;
```

日志生成的到Nginx根目录logs/access.log文件，默认使用“main”日志格式，也可以自定义格式。

**默认“main”日志格式：**

```json
log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '

                    '$status $body_bytes_sent "$http_referer" '

                    '"$http_user_agent" "$http_x_forwarded_for"';
```

参数明细表：

| $remote_addr          | 客户端的ip地址(代理服务器，显示代理服务ip)           |
| --------------------- | ---------------------------------------------------- |
| $remote_user          | 用于记录远程客户端的用户名称（一般为“-”）            |
| $time_local           | 用于记录访问时间和时区                               |
| $request              | 用于记录请求的url以及请求方法                        |
| $status               | 响应状态码，例如：200成功、404页面找不到等。         |
| $body_bytes_sent      | 给客户端发送的文件主体内容字节数                     |
| $http_user_agent      | 用户所使用的代理（一般为浏览器）                     |
| $http_x_forwarded_for | 可以记录客户端IP，通过代理服务器来记录客户端的ip地址 |
| $http_referer         | 可以记录用户是从哪个链接访问过来的                   |

> 注意：php，tomcat等后端服务获取的客户端ip等就是通过nginx传过来的



**2.nginx日志切割**

可以结合shell脚本实现，也可以使用日志切割工具（cronolog，）。

```shell
#!/bin/bash
s_log="/usr/local/nginx/logs/access.log"
d_log="/data/backup/nginx-$(date +%F).log"
d_log_dir="/data/backup"

#判断备份目录是否存在，不存在则创建
if [ ! -d "$d_log_dir" ];then
       mkdir -p "$d_log_dir"
fi

#判断原日志文件是否存在，存在则移动并改名
if [ -f "$s_log" ];then
        mv "$s_log" "$d_log"
fi

#以下两条命令任选其一：
#kill -USR1 `cat /usr/local/nginx/logs/nginx.pid`
/usr/local/nginx/sbin/nginx -s reopen
```

**创建crontab设置作业**

\#设置日志文件存放目录crontab -e

```shell
*/1 * * * *  /bin/bash /usr/local/nginx/nginx_log.sh
```

**nginx -s reopen**

执行完上述命令后，日志目录中自动生成了一个新的"access.log"文件，
再次访问nginx，会发现新生成的日志已经写入到了新生成的"access.log"文件中了。

**原理解析：**

发送信号，其实是执行：

```bash
kill -USR1 `cat /usrlocal/nginx/logs/nginx.pid`
```



## **51、nginx 管理常用的几个信号**

**master进程接收的信号:**

| 信号名   | 含义                                   | 对应nginx命令行 |
| :------- | :------------------------------------- | :-------------- |
| TERM,INT | 终止进程                               | stop            |
| QUIT     | 完成请求链接,优雅的终止进程            | quit            |
| HUP      | 平滑重启，重新加载配置文件             | reload          |
| USR1     | 重新打开日志文件，在切割日志时用途较大 | reopen          |
| USR2     | 平滑升级,热部署使用                    | 无              |
| WINCH    | 平滑关闭进程,热部署使用                | 无              |

**worker接收的信号**

| 信号名   | 含义                        | 对应nginx命令行 |
| :------- | :-------------------------- | :-------------- |
| TERM,INT | 终止进程                    | stop            |
| QUIT     | 完成请求链接,优雅的终止进程 | quit            |
| WINCH    | 平滑关闭进程,热部署使用     | 无              |

**例子:**

为了更加直观,我们将nginx.conf worker进程改为1

```javascript
worker_processes  1;
```

**更改后,我们重新加载配置文件,可使用**

```javascript
nginx -s reload
```

> 或者可以使用 kill -HUP pid，pid需要你去查看nginx master进程pid获取. 此命令针对worker进程无效

**重新生成日志文件**

```javascript
 nginx -s reopen
 或者
 # kill -USR1 1144
```

**停掉子进程**

```shell
kill -TERM 1376
```



## 52、nginx 常用命令

```
nginx -s quit //优雅停止nginx，有连接时会等连接请求完成再杀死worker进程
nginx -s stop //快速关闭Nginx，可能不保存相关信息，并迅速终止web服务
nginx -s reload //优雅重启，并重新载入配置文件nginx.conf
nginx -s reopen //重新打开日志文件，一般用于切割日志
nginx -v //查看版本
nginx -t //检查nginx的配置文件
nginx -h //查看帮助信息
nginx -V //详细版本信息，包括编译参数
nginx -c filename //指定配置文件
```



## 53、nginx 跨域

直接请求nginx也是会报跨域错误的这里设置允许跨域;如果代理地址已经允许跨域则不需要这些, 否则报错(虽然这样nginx跨域就没意义了)

```shell
add_header Access-Control-Allow-Origin *;
add_header Access-Control-Allow-Headers X-Requested-With;
add_header Access-Control-Allow-Methods GET,POST,OPTIONS;
```



## 54、nginx 的 location 说明

location 表示位置的概念，类似于 if，即满足什么条件，就做什么

Nginx的location语法 

```
location [=|~|~*|^~] /uri/ { … }

=         严格匹配。如果请求匹配这个location，那么将停止搜索并立即处理此请求
~         区分大小写匹配(可用正则表达式)
~*        不区分大小写匹配(可用正则表达式)
!~        区分大小写不匹配
!~*       不区分大小写不匹配
^~        如果把这个前缀用于一个常规字符串,那么告诉nginx 如果路径匹配那么不测试正则表达式
```

 

示例1：

```
location  / { }
```

匹配任意请求

 

示例2：

```
location ~* .(gif|jpg|jpeg)$ ｛
	rewrite .(gif|jpg|jpeg)$ /logo.png;
｝
```

不区分大小写匹配任何以gif、jpg、jpeg结尾的请求，并将该请求重定向到 /logo.png请求

 

示例3：

```
location ~ ^.+\.txt$ {
	root /usr/local/nginx/html/;
}
```

区分大小写匹配以.txt结尾的请求，并设置此location的路径是/usr/local/nginx/html/。也就是以.txt结尾的请求将访问/usr/local/nginx/html/ 路径下的txt文件



## 55、nginx的alias与root的区别

root    实际访问文件路径会拼接URL中的路径
alias   实际访问文件路径不会拼接URL中的路径
示例如下：

```
location ^~ /sta/ {  
   alias /usr/local/nginx/html/static/;  
}
```

请求：http://test.com/sta/sta1.html
实际访问：/usr/local/nginx/html/static/sta1.html 文件

```
location ^~ /tea/ {  
   root /usr/local/nginx/html/;  
}
```

请求：http://test.com/tea/tea1.html
实际访问：/usr/local/nginx/html/tea/tea1.html 文件



## 56、nginx用户访问控制与认证模块

用户访问控制与认证模块ngx_http_access_module、ngx_http_auth_basic_module

**一、用户访问控制模块ngx_http_access_module**

如果在Nginx中想控制某个路径无法让指定用户访问（限制IP访问），需要使用到的模块是ngx_http_access_module。说模块名可能不熟悉，但是说到allow和deny就一定知道是干什么的了。这个模块是默认就会安装的，除非在编译时加上了--without-http_access_module。下面是ngx_http_access_module的配置语法示例：

```
location / {
	deny  192.168.1.120;
	allow 192.168.1.0/24;
	allow 10.1.1.0/16;
	deny  all;
}
```


Nginx和iptables的匹配规则一样，从上往下进行匹配，只要遇到符合条件的规则就不再继续往下匹配。如上例子中首先禁止192.168.1.120这个IP的访问，然后允许了另外2个网段的IP访问，最后不符合匹配条件的IP全部禁止访问。在实际工作中只要记住想禁止哪个IP访问就deny掉对应的IP，想允许则加上allow ip，想禁止或者允许所有的IP访问就使用allow all或者deny all。

**二、用户认证模块ngx_http_auth_basic_module**

Nginx进行用户名密码验证的话是通过ngx_http_auth_basic_module模块实现，该模块可作用范围http，server，location，limit_except，语法如下：

```
location / {
    auth_basic           "Please input your name";
    auth_basic_user_file /etc/nginx/htpasswd;
}
```



## 57、nginx的upstream模块和负载调度算法



**upstream模块相关说明**
1、upstream模块应放于nginx.conf配置的http{}标签内
2、upstream模块默认算法是wrr (权重轮询 weighted round-robin)

![1585367100786](assets/1585367100786.png)





**一、分配方式**
Nginx的upstream支持5种分配方式，下面将会详细介绍，其中前三种为Nginx原生支持的分配方式，后两种为第三方支持的分配方式。

1、rr轮询（默认调度算法，静态调度算法）
轮询是upstream的默认分配方式，即每个请求按照时间顺序轮流分配到不同的后端服务器，如果某个后端服务器down掉后，能自动剔除。

```shell
upstream backend {
    server 192.168.1.101:8888;
    server 192.168.1.102:8888;
    server 192.168.1.103:8888;
}
```

2、wrr（权重轮询，静态调度算法）
轮询的加强版，即可以指定轮询比率，weight和访问几率成正比，主要应用于后端服务器异质的场景下。

```shell
upstream backend {
    server 192.168.1.101 weight=1;
    server 192.168.1.102 weight=2;
    server 192.168.1.103 weight=3;
}
```

3、ip_hash（静态调度算法）
每个请求按照访问ip（即Nginx的前置服务器或者客户端IP）的hash结果分配，这样每个访客会固定访问一个后端服务器，可以解决session一致问题。

```shell
upstream backend {
    ip_hash;
    server 192.168.1.101:7777;
    server 192.168.1.102:8888;
	server 192.168.1.103:9999;
}
```

注意：
1、当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。
2、导致负载不均衡。



4、fair（动态调度算法）
fair顾名思义，公平地按照后端服务器的响应时间（rt）来分配请求，响应时间短即rt小的后端服务器优先分配请求。如果需要使用这种调度算法，必须下载Nginx的upstr_fair模块。

```shell
upstream backend {
    server 192.168.1.101;
	server 192.168.1.102;
    server 192.168.1.103;
    fair;
}
```

5、url_hash，目前用consistent_hash替代url_hash
与ip_hash类似，但是按照访问url的hash结果来分配请求，使得每个url定向到同一个后端服务器，主要应用于后端服务器为缓存时的场景下。

```shell
upstream backend {
    server 192.168.1.101;
    server 192.168.1.102;
    server 192.168.1.103;
    hash $request_uri;
    hash_method crc32;
}
```

 

其中，hash_method为使用的hash算法，需要注意的是：此时，server语句中不能加weight等参数。

提示：url_hash用途cache服务业务，memcached，squid，varnish。特点：每个rs都是不同的。



6、least_connleast_conn最小连接数算法

会根据后端节点的连接数来决定分配情况，哪个机器连接数少就分发。



## 58、负载均衡概念和实现

概念：

1）对用户的访问请求进行调度管理

2）对用户的访问请求进行压力分担

实现：

1）硬件实现负载

① F5 硬件设备

② A10 硬件设备

2）软件实现负载

① Nginx（7 层，1.9 之后支持 4 层负载）

② LVS（4 层）

③ HAproxy（4 层，7 层）



## 59、Linux常用快捷键操作

| 快捷键                 | 功能说明                                                     |
| ---------------------- | ------------------------------------------------------------ |
| 最有用快捷键           |                                                              |
| tab                    | 命令或路径等的补全键，Linux最有用快捷键*                     |
| 移动光标快捷键         |                                                              |
| Ctrl+a                 | 光标回到命令行首*                                            |
| Ctrl+e                 | 光标回到命令行尾*                                            |
| Ctrl+f                 | 光标向右移动一个字符（相当于方向键右键）                     |
| Ctrl+b                 | 光标向左移动一个字符（相当于方向键左键）                     |
| 剪切、粘贴、清除快捷键 |                                                              |
| Ctrl+Insert            | 复制命令行内容*                                              |
| Shift+Insert           | 粘贴命令行内容*                                              |
| Ctrl+k                 | 剪切（删除）光标处到行尾的字符*                              |
| Ctrl+u                 | 剪切（删除）光标处到行首的字符*                              |
| Ctrl+w                 | 剪切（删除）光标前的一个单词                                 |
| Ctrl+y                 | 粘贴Ctrl+u，Ctrl+k，Ctrl+w删除的文本                         |
| Ctrl+c                 | 中断终端正在执行的任务或者删除整行*                          |
| Ctrl+h                 | 删除光标所在处的前一个字符（相当于退格键）                   |
| 重复执行命令快捷键     |                                                              |
| Ctrl+d                 | 退出当前Shell命令行*                                         |
| Ctrl+r                 | 搜索命令行使用过的历史命令记录*                              |
| Ctrl+g                 | 从执行Ctrl+r的搜索历史命令模式退出                           |
| Esc+.(点)              | 获取上一条命令的最后的部分（空格分隔）*                      |
| 控制快捷键             |                                                              |
| Ctrl+l                 | 清除屏幕所有内容，并在屏幕最上面开始一个新行，等同clear命令* |
| Ctrl+s                 | 锁定终端，使之无法输入内容                                   |
| Ctrl+q                 | 解锁执行Ctrl+s的锁定状态                                     |
| Ctrl+z                 | 暂停执行在终端运行的任务*                                    |
| !号开头的快捷命令      |                                                              |
| !!                     | 执行上一条命令                                               |
| !pw                    | 执行最近以pw开头的命令*                                      |
| !pw:p                  | 仅打印最近pw开头的命令，但不执行                             |
| !num                   | 执行历史命令列表的第num(数字)条命令*                         |
| !$                     | 上一条命令的最后一个参数，相当于Esc+.(点)                    |
| ESC相关                |                                                              |
| Esc+.(点)              | 获取上一条命令的最后的部分（空格分隔）*                      |
| Esc+b                  | 移动到当前单词的开头                                         |
| Esc+f                  | 移动到当前单词的结尾                                         |
| Esc+t                  | 颠倒光标所在处及其相邻单词的位置                             |



## 60、脚本查找最后创建时间是三天前，后缀是*.log的文件并删除

```
find .-ctime +3 -name '*.log' | rm -rf
```

## 61、统计ip访问情况，要求分析nginx访问日志，找出访问页面数量在前十位的ip

awk '{print $1}' access.log| uniq -c | sort -rn | head -10



## 62、编写shell 脚本将/usr/local/test 目录下大于100K 的文件转移到/tmp目录下

```
find /usr/local/test -type f -size +100k -exec mv {} /tmp/
```

或

```shell
#!/bin/bash
filelist=$(ls  /usr/local/test -l | grep "^-" | awk '{print $9}')
filepath="/usr/local/test"
for file in $filelist
do
	filesize=$(du -s $filepath$file |awk '{print $1}') 
	if [ $filesize -gt 100]
		then
			mv $filepath$file /tmp/
	fi
done
```



## 63、tomcat 优化

安全优化
配置文件里面的指定的开启服务，关闭服务的端口。
① 关闭端口保护 8005 SHUTDOWN
② ajp 连接端口保护（阿帕奇与 java 直接连接的端口） 8009 注释
③ 禁用管理端（也就是网页的三个选项）
④ 降权启动 （降低用户权限启动，也就是以普通用户的身份去运行 tomcat）

性能优化
tomcat 性能取决于你的内存大小
提供四种办法：
① 上策：优化代码
② 中策：jvm 优化机制 垃圾回收机制 把不需要的内存回收
③ 优化 jvm--优化垃圾回收策略
④ 优化 catalina.sh 配置文件。

内存优化
Tomcat内存优化主要是对 tomcat 启动参数优化，我们可以在 tomcat 的启动脚本 catalina.sh 中设置 java_OPTS 参数。

并发优化
调整连接器connector的并发处理能力；在Tomcat 配置文件 server.xml 中的

缓存压缩优化
打开tomcat的压缩功能；tomcat的压缩优化就是将返回的html页面等内容经过压缩，压缩成gzip格式之后，发送给浏览器，浏览器在本地解压缩的过程。



## 64、LVS负载均衡（LVS简介、三种工作模式、十种调度算法）



**一、LVS简介**



​       LVS（Linux Virtual Server）即Linux虚拟服务器，是由章文嵩博士主导的开源负载均衡项目，目前LVS已经被集成到Linux内核模块中。该项目在Linux内核中实现了基于IP的数据请求负载均衡调度方案，其体系结构如图1所示，终端互联网用户从外部访问公司的外部负载均衡服务器，终端用户的Web请求会发送给LVS调度器，调度器根据自己预设的算法决定将该请求发送给后端的某台Web服务器，比如，轮询算法可以将外部的请求平均分发给后端的所有服务器，终端用户访问LVS调度器虽然会被转发到后端真实的服务器，但如果真实服务器连接的是相同的存储，提供的服务也是相同的服务，最终用户不管是访问哪台真实服务器，得到的服务内容都是一样的，整个集群对用户而言都是透明的。最后根据LVS工作模式的不同，真实服务器会选择不同的方式将用户需要的数据发送到终端用户，LVS工作模式分为NAT模式、TUN模式、以及DR模式。

![img](assets/clipboard-1585570640069.png)





**二、三种工作模式的解析。**



**1、基于NAT的LVS模式负载均衡**

​      NAT（Network Address Translation）即网络地址转换，其作用是通过数据报头的修改，使得位于企业内部的私有IP地址可以访问外网，以及外部用用户可以访问位于公司内部的私有IP主机。VS/NAT工作模式拓扑结构如图2所示，LVS负载调度器可以使用两块网卡配置不同的IP地址，eth0设置为私钥IP与内部网络通过交换设备相互连接，eth1设备为外网IP与外部网络联通。

​       第一步，用户通过互联网DNS服务器解析到公司负载均衡设备上面的外网地址，相对于真实服务器而言，LVS外网IP又称VIP（Virtual IP Address），用户通过访问VIP，即可连接后端的真实服务器（Real Server），而这一切对用户而言都是透明的，用户以为自己访问的就是真实服务器，但他并不知道自己访问的VIP仅仅是一个调度器，也不清楚后端的真实服务器到底在哪里、有多少真实服务器。

   第二步，用户将请求发送至124.126.147.168，此时LVS将根据预设的算法选择后端的一台真实服务器（192.168.0.1~192.168.0.3），将数据请求包转发给真实服务器，并且在转发之前LVS会修改数据包中的目标地址以及目标端口，目标地址与目标端口将被修改为选出的真实服务器IP地址以及相应的端口。

​    第三步，真实的服务器将响应数据包返回给LVS调度器，调度器在得到响应的数据包后会将源地址和源端口修改为VIP及调度器相应的端口，修改完成后，由调度器将响应数据包发送回终端用户，另外，由于LVS调度器有一个连接Hash表，该表中会记录连接请求及转发信息，当同一个连接的下一个数据包发送给调度器时，从该Hash表中可以直接找到之前的连接记录，并根据记录信息选出相同的真实服务器及端口信息。

![img](assets/clipboard-1585570640070.png)



**2、基于TUN的LVS负载均衡**

​       在LVS（NAT）模式的集群环境中，由于所有的数据请求及响应的数据包都需要经过LVS调度器转发，如果后端服务器的数量大于10台，则调度器就会成为整个集群环境的瓶颈。我们知道，数据请求包往往远小于响应数据包的大小。因为响应数据包中包含有客户需要的具体数据，所以LVS（TUN）的思路就是将请求与响应数据分离，让调度器仅处理数据请求，而让真实服务器响应数据包直接返回给客户端。VS/TUN工作模式拓扑结构如图3所示。其中，IP隧道（IP tunning）是一种数据包封装技术，它可以将原始数据包封装并添加新的包头（内容包括新的源地址及端口、目标地址及端口），从而实现将一个目标为调度器的VIP地址的数据包封装，通过隧道转发给后端的真实服务器（Real Server），通过将客户端发往调度器的原始数据包封装，并在其基础上添加新的数据包头（修改目标地址为调度器选择出来的真实服务器的IP地址及对应端口），LVS（TUN）模式要求真实服务器可以直接与外部网络连接，真实服务器在收到请求数据包后直接给客户端主机响应数据。

![img](assets/clipboard-1585570640070.png)

**3、基于DR的LVS负载均衡**

​	在LVS（TUN）模式下，由于需要在LVS调度器与真实服务器之间创建隧道连接，这同样会增加服务器的负担。与LVS（TUN）类似，DR模式也叫直接路由模式，其体系结构如图4所示，该模式中LVS依然仅承担数据的入站请求以及根据算法选出合理的真实服务器，最终由后端真实服务器负责将响应数据包发送返回给客户端。与隧道模式不同的是，直接路由模式（DR模式）要求调度器与后端服务器必须在同一个局域网内，VIP地址需要在调度器与后端所有的服务器间共享，因为最终的真实服务器给客户端回应数据包时需要设置源IP为VIP地址，目标IP为客户端IP，这样客户端访问的是调度器的VIP地址，回应的源地址也依然是该VIP地址（真实服务器上的VIP），客户端是感觉不到后端服务器存在的。由于多台计算机都设置了同样一个VIP地址，所以在直接路由模式中要求调度器的VIP地址是对外可见的，客户端需要将请求数据包发送到调度器主机，而所有的真实服务器的VIP地址必须配置在Non-ARP的网络设备上，也就是该网络设备并不会向外广播自己的MAC及对应的IP地址，真实服务器的VIP对外界是不可见的，但真实服务器却可以接受目标地址VIP的网络请求，并在回应数据包时将源地址设置为该VIP地址。调度器根据算法在选出真实服务器后，在不修改数据报文的情况下，将数据帧的MAC地址修改为选出的真实服务器的MAC地址，通过交换机将该数据帧发给真实服务器。整个过程中，真实服务器的VIP不需要对外界可见。

![img](assets/clipboard-1585570640070.png)

**三、LVS负载均衡调度算法**

​      根据前面的介绍，我们了解了LVS的三种工作模式，但不管实际环境中采用的是哪种模式，调度算法进行调度的策略与算法都是LVS的核心技术，LVS在内核中主要实现了一下十种调度算法。

**1.轮询调度**

轮询调度（Round Robin 简称'RR'）算法就是按依次循环的方式将请求调度到不同的服务器上，该算法最大的特点就是实现简单。轮询算法假设所有的服务器处理请求的能力都一样的，调度器会将所有的请求平均分配给每个真实服务器。

**2.加权轮询调度**

加权轮询（Weight Round Robin 简称'WRR'）算法主要是对轮询算法的一种优化与补充，LVS会考虑每台服务器的性能，并给每台服务器添加一个权值，如果服务器A的权值为1，服务器B的权值为2，则调度器调度到服务器B的请求会是服务器A的两倍。权值越高的服务器，处理的请求越多。

**3.最小连接调度**

最小连接调度（Least Connections 简称'LC'）算法是把新的连接请求分配到当前连接数最小的服务器。最小连接调度是一种动态的调度算法，它通过服务器当前活跃的连接数来估计服务器的情况。调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1；当连接中断或者超时，其连接数减1。

（集群系统的真实服务器具有相近的系统性能，采用最小连接调度算法可以比较好地均衡负载。)

**4.加权最小连接调度**

加权最少连接（Weight Least Connections 简称'WLC'）算法是最小连接调度的超集，各个服务器相应的权值表示其处理性能。服务器的缺省权值为1，系统管理员可以动态地设置服务器的权值。加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。

**5.基于局部的最少连接**

基于局部的最少连接调度（Locality-Based Least Connections 简称'LBLC'）算法是针对请求报文的目标IP地址的 负载均衡调度，目前主要用于Cache集群系统，因为在Cache集群客户请求报文的目标IP地址是变化的。这里假设任何后端服务器都可以处理任一请求，算法的设计目标是在服务器的负载基本平衡情况下，将相同目标IP地址的请求调度到同一台服务器，来提高各台服务器的访问局部性和Cache命中率，从而提升整个集群系统的处理能力。LBLC调度算法先根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则使用'最少连接'的原则选出一个可用的服务器，将请求发送到服务器。

**6.带复制的基于局部性的最少连接**

带复制的基于局部性的最少连接（Locality-Based Least Connections with Replication  简称'LBLCR'）算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统，它与LBLC算法不同之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。按'最小连接'原则从该服务器组中选出一一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按'最小连接'原则从整个集群中选出一台服务器，将该服务器加入到这个服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。

**7.目标地址散列调度**

目标地址散列调度（Destination Hashing 简称'DH'）算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。

**8.源地址散列调度U**

源地址散列调度（Source Hashing  简称'SH'）算法先根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法的相同，它的算法流程与目标地址散列调度算法的基本相似。

**9.最短的期望的延迟**

最短的期望的延迟调度（Shortest Expected Delay 简称'SED'）算法基于WLC算法。举个例子吧，ABC三台服务器的权重分别为1、2、3 。那么如果使用WLC算法的话一个新请求进入时它可能会分给ABC中的任意一个。使用SED算法后会进行一个运算

A：（1+1）/1=2   B：（1+2）/2=3/2   C：（1+3）/3=4/3   就把请求交给得出运算结果最小的服务器。

**10.最少队列调度**

最少队列调度（Never Queue 简称'NQ'）算法，无需队列。如果有realserver的连接数等于0就直接分配过去，不需要在进行SED运算。



## 65、进程和线程的区别 

进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响。 
而线程只是进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间， 
一个线程死掉就等于整个进程死掉。 
所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些



## 66、RabbitMQ是什么

RabbitMQ也就是消息队列中间件，消息中间件是在消息的传息过程中保存消息的容器
消息中间件再将消息从它的源中到它的目标中标时充当中间人的作用
队列的主要目的是提供路由并保证消息的传递；如果发送消息时接收者不可用
消息队列不会保留消息，直到可以成功地传递为止，当然，消息队列保存消息也是有期限地



## 67、优化Linux系统

1. 不用root，添加普通用户，通过sudo授权管理

2. 更改默认的远程连接SSH服务端口及禁止root用户远程连接

3. 定时自动更新服务器时间

4. 配置国内yum源

5. 关闭selinux及iptables（iptables工作场景如果有外网IP一定要打开，高并发除外）

6. 调整文件描述符的数量

7. 精简开机启动服务（crond rsyslog network sshd）

8. 内核参数优化（/etc/sysctl.conf）

9. 更改字符集，支持中文，但建议还是用英文字符集，防止乱码

10. 锁定关键系统文件
11. 清空/etc/issue，去除系统及内核版本登录前的屏幕显示



## 68、elk详解

**1.ELK分别表示什么？**

三个开源软件 elasticsearch logstash kibana

**2.elasticsearch的特点是什么**

elasticsearch，基于lucene开发，隐藏了复杂性，提供了简单易用的restful api接口，Java api 接口（以及其他语言的api接口）Elasticsearch是当前主流的分布式大数据存储和搜索引擎，可以为用户提供强大的全文本检索能力，广泛应用于日志检索，全站搜索等领域。Logstash作为Elasicsearch常用的实时数据采集引擎，可以采集来自不同数据源的数据，并对数据进行处理后输出到多种输出源，是Elastic Stack 的重要组成部分。

elasticsearch基本特点：

①：分布式的文档存储引擎

②：分布式的搜索引擎和分析引擎

③：分布式，支持PB级数据

**3.kibana的特点和作用是什么**

所有类型的数据集中处理

不同模式和格式数据的正常化

自定义日志格式的迅速扩展

为自定义数据源轻松添加插件

提供web页面进行可视化展示

**4.logstash的特点和作用是什么**

Logstash 能够动态地采集、转换和传输数据，不受格式或复杂度的影响。利用 Grok 从非结构化数据中派生出结构，从 IP 地址解码出地理坐标，匿名化或排除敏感字段，并简化整体处理过程。

Logstash 是开源的服务器端数据处理管道，能够同时 从多个来源采集数据、转换数据，然后将数据发送到您最喜欢的 “存储库” 中。（我们的存储库当然是 Elasticsearch。）

可伸缩性 可过滤 作用就是一款强大的数据处理，可实现数据传输，格式处理，格式化输出，还有强大的插件功能，常用于日志处理

**5.ELK能做什么？**

ELK组件在海量日志系统的运维中，可用于解决：

\- 分布式日志数据集中式查询和管理

\- 系统监控，包含系统硬件和应用各个组件的监控

\- 故障排查

\- 安全信息和事件管理

\- 报表功能

**6.ELK在你使用的过程中主要用来做什么？**

分析系统日志，访问日志，应用日志，分析数据

**7.elasticSearch 中的集群，节点，文档，类型和索引是什么**

集群：一个集群是由一个多个组成的集合，集群上的节点将会存储数据，并提供跨界点的所用和搜索过滤

节点：一个节点就是一个elasticsearch服务，可以是现存书数据，索引并且搜索的功能，和集群一样，每一个节点都有唯一的名称为标识

文档：elaticsearch是面向文档这意味着特可以存储关于整个对象或文档，然而它不仅仅是为存储，还会索

引每个文档的内容是指可以被搜索

索引：在elasticsearch中存储数据的行为较为索引

类型：文档属于一种类型而这类型存在于索引中，我们可以画一些简单的对比图来比传统关系数据库



## 69、Redis和memcache的区别	

(1) Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。 

(2) redis在数据支持上要比memecache多的多。

(3) memecache 把数据全部存在内存之中，redis有部份存在硬盘上，这样能保证数据的持久性，支持数据的持久化比如RDB和AOF两种持久化存储方式

(4) redis目前官方只支持LINUX 上去运行

(5) Redis支持数据的备份，即master-slave模式的数据备份

(6) 个人总结一下，有持久化需求或者对数据结构和处理有高级要求的应用，选择redis，其他简单的key/value存储，选择memcache



## 70、linux中的软硬链接

1.5.1 链接的概念

在Linux系统中，链接分为两种：一种为硬链接（Hard Link），另一种为软链接（Symbolic Link or Soft Link）。链接由ln命令创建，默认不带参数的情况下，执行ln命令创建的是硬链接，# ln -s命令创建的是软链接。创建命令如下：

硬链接：# ln  源文件  创建的目标文件

软链接：# ln  -s  源文件  创建的目标文件

 

1.5.2 硬链接

硬链接通过索引节点（inode）来进行链接。**在Linux文件系统中，多个文件名指向同一个索引节点（inode），这是被允许的，这种情况被称为文件的硬链接。硬链接的作用之一，就是允许一个文件拥有多个有效路径（多个入口），这样用户可以建立硬链接到重要的文件，防止“误删”源数据。**只要文件还存在一个以上的硬链接，删除其中的一个硬链接（删除了该文件的链接指向），不影响索引节点和其他的链接，即数据文件实体并未被删除。只有当最后一个链接被删除后，此时，如果有新的数据要存储到硬盘上，或系统通过类似fsck检查磁盘时，被删除文件的数据块及目录的链接才会被释放，空间被新的数据覆盖。**也就是说，在Linux系统中，**删除静态文件（没有进程调用，目录也是文件）的条件是与之相关的所有硬链接文件均被删除，文件才会被删除。**

 

**对硬链接有如下限制：** 

不能对目录文件做硬链接。 

不能在不同的文件系统之间做硬链接。

就是说，链接文件和被链接文件必须位于同一个文件系统中。

 

1.5.3 软链接

软链接（Soft Link）也叫符号链接（Symbolic Link）。Linux系统里的软链接就相当于Windows里的快捷方式。软链接可以理解为一个文本文件，这个文件中包含有软链接指向另一源文件的位置信息内容。因此，通过软链接可以快速定位到软链接所指向的源文件实体。



## 71、网站访问慢的原因

1、服务器负载过大忙不过来，无法承担巨大的流量。

2、访问量过载

3、网站代码的繁琐

4、站点存在大量的JS调用

5、服务器出口带宽不够用。

6、服务器负载过大忙不过来，无法承担巨大的流量。

7、数据库的瓶颈，数据库文件过大，造成读取缓慢，没有建立索引，造成每次查询都对数据库进行全局查询。

8、没有设置CDN。

9、可能遭受到了分布式拒绝攻击即DDOS攻击或者中病毒木马。

10、死链接：死链接是指残留的网站中不存在的页面，即网站改变前的页面，改动后删除此页面，但是搜索引擎已经收录了，这样的页面称为死链接，用户通过死链接访问是会出现打不开的现象

11、站点图片大：网站都会有大量的图片，如果这些图片没有被优化，就会很大。会影响网站的打开速度

 

**怎么优化网站的打开速度**

解决办法：

1.查看线上服务器的负载情况，CPU负载，内存负载，网络带宽，查看是否已经过载。

2.查看网络连接情况，是否受到DDOS攻击，消耗尽带宽资源，造成无法提供服务。

3.查看MySQL数据库的日志文件，查看mysql慢查询日志，查看造成MySQL访问过慢的原因。

4.可以查看应用程序的日志，如Apache，nginx，PHP，Tomcat日志文件，找出报错原因，查看是否是代码问题。

5.精简代码

6.优化缓存

7.图片压缩



## 72、zabbix分布式监控

![1585571215014](assets/1585571215014.png)

**思路：**

**Zabbix-agent 端======》zabbix-proxy======》zabbix-server 端**

**所以：**

**Zabbix-agent 的服务端的 ip 为 zabbix-proxy 的 IP 地址**

**Zabbix-proxy 的服务端的 ip 为 zabbix-server 的 IP 地址**

**zabbix有哪些监控方式，主动还是被动(主被动模式都是相对于zabbix-agent来说的)**

**主动**是zabbix-agent主动获取的主机监控项列表，并主动将监控项内需要检测的数据提交给zabbix-server或zabbix-proxy

**被动**是zabbix-server想zabbix-agent请求获取监控项的数据，zabbix-agent返回数据





# **面试技巧篇**

\1. 公司是做什么业务的

答：贯通云网快递平台网页版。集合了国内七大现有快递公司的业务终端，并在陆续扩展中。集中了在线填写，预约发件；智能跟踪，智能查询，快件信息管理等优点！

指尖快递APP---基于线上平台数据，建立快递代办点业务体系。

\2. 2.公司有多少服务器

答：80台

\3. 你负责多少台

答：我主要负责网页端的40台

\4. 每台服务器都跑的啥

答：6台web，两台redis，6台数据库，还有nginx，tomcat，LVS负载+keepalived高可用什么的，剩下的都是平时测试用的。

\5. 公司规模多大

答：中小型企业。

\6. 公司有个运维

答：2个，我负载web端，另一个负责APP端。

\7. 你的汇报对象是谁

答：我们老大

\8. 你们公司用的什么语言

答：开发用的是JAVA

\9. 你们的开发有多少人

答：开发是3个

\10. 运维怎么分工的

答：也没啥分工，一起干

\11. 你的期望薪资是多少

答：因为上家公司给的是13K，所以 不低于13吧

\12. 你平时出差多吗

答：出差不多，因为公司业务主要都在线上。说实话我还是挺想出去走走的。

\13. 你们学校是统招还是非统招

答：统招的。

\14. 你们学校是全日制的吗

答：是全日制的

\15. 你离职原因是啥

答：因为学历问题，公司要给我做降薪处理，有点接受不了

\16. 你觉得你的优点和缺点是啥

答：优点：沟通能力强，团队协作能力强，乐于助人，喜欢学习。

​    缺点：长得丑算吗？

\17. 你工作之余有什么爱好  

答：看一些技术方面的书，研究一些新的技术。

\18. 你最近有学习过哪些新技术

答：python

19.你住的地方，离公司有多远

公司在哪里，我就住哪里

20.你们公司哪年成立的

答：2014年5月成立的。

21.每台服务器都跑的啥 答：6台web，两台redis，6台数据库，还有nginx，tomcat，LVS负载+keepalived高可用什么的，剩下的都是平时测试用的

22.你们公司服务器都是什么型号

答：戴尔R710  R720 

23机房温度是多少

15--22

24.你对加班怎么看的

答：我觉得IT行业加班很正常啊，如果我有幸进入公司的话，我会主动去加班，尽快熟悉公司业务，能早点上手工作。

 

25.到公司需要多长时间？

不堵车的时候半个小时左右，当然我更喜欢住的公司近一点，如果有幸来公司入职，我肯定会在附近找一个住的地方

27.如果你跟领导的意见不一样，你会如何做

答：那就要看是什么方面的了，如果是技术方面的话，我觉得我会跟领导私下再去沟通一下，跟领导阐明我的观点和理由，剩下的就看领导的决定了。

 

28.每天你作为运维每天工作都干嘛？

  看流量，看报警，搭环境，改配置，处理开发人员的需求， 下午上线，  做项目（权限管理，集中分治，跳板机） 内网的活，网络上不了网有时候也负责。

近一年主要做的是做运维规范，服务器维护升级规范，文档规范，服务器权限规范等等，都是我写好，让老大审批，然后就有分歧的地方再商讨。

这段时间因为要离职了，所以交接内容我也在整理文档，在面试新员工方面我也参与

 

29.列举你所知道的攻击手段，以及针对性的安全措施？

Ddos攻击、暴力破解密码

Ddos攻击防范：

1.对网站进行Ddos压力测试，选择安全的机房，对架构优化尽量多方cache

2.使用Ddosdeflate工具进行检测，如果访问量超过某值，对访问的IP进行禁封

暴力破解密码防范：使用fail2ban工具进行检测，如果输入密码次数超过定义的次数，对访问的IP进行禁封

 

**30.你们是怎么处理报警的？**

我们都是按照报警返回来的信息来进行处理，例如服务的运行状态出现意外

我们也会对他进行一个分级：一级就是通过邮箱报警一些简单地事故一般都是初级运维来处理，二级就是通过微信报警来通知我们，三级的话就是电话报警是直接打给我们老大，我们老大进行处理

\31. 公司代码上线是怎么做的，发布周期是多长时间，一般什么时候上线 

答： 最初始的代码上线

dev: 开发服务版本库 bate 测试服务版本库， online线上服务版本库 测试通过后，再客户端选2000到3000个用户强制弹窗，让其更新版本。进行灰度发布。 有bug修复后再走一遍流程。 所谓的灰度发布： 根据自己的配置，将部分用户的流量导到新系统来验证新功能的修改，一旦出现问题可以马上修复。 一周上线一次，周四上线，有问题就回滚，周五继续上线

\32. 什么是灰度发布，什么是灰度测试 答： 所谓的灰度发布： 根据自己的配置，将部分用户的流量导到新系统来验证新功能的修改，一旦出现问题可以马上修复

33.代码如何回滚，用jenkins如何实现 

答：发布：jenkins配置好代码路径（SVN或GIT），然后拉代码，打tag。需要编译就编译，编译之后推送到发布服务器（jenkins里面可以调脚本），然后从分发服务器往下分发到业务服务器上。发布：jenkins配置好代码路径（SVN或GIT），然后拉代码，打tag。需要编译就编译，编译之后推送到发布服务器（jenkins里面可以调脚本），然后从分发服务器往下分发到业务服务器上。 回滚：按照版本号到发布服务器找到对应的版本推送

34.上线前开发给你的包是什么包 答：jar war

35.svn与git相比有什么区别？ 

1）git 只关心文件数据的整体是否发生改变，而svn关心 的是内容是否改变 

2）git的绝大多数操作只需要访问本地的文件和资源，不用联网查看所有的历史版本记录，而svn需要联网 

3） svn断网后无法commit代码，而git可以先commit到本地仓库 

4）git克隆一个完整项目非常快，而svn非常慢 范例一： 我们公司用的是SVN，但我私下里也学习了下git,个人感觉，SVN更好上手，但是论功能强大的化还是git好一些，比如同样是克隆一个完整项目，git就比svn快，而且有时候，一旦断网git可以commit到本地仓库，但是SVN就没法commit . 

36.代码上线时运维需要做的事情？ 

答：配合开发搭建测试环境，调试，测试代码 采购阿里云服务器，安装系统，配置服务 部署上线过程中发现bug，与开发沟通，前端沟通，开发解决完继续上线 出现问题，回滚（需要提前确定好回滚机制） 备份恢复： 

37.备份分为哪几种？ 

答：完全备份 增量备份 文件备份 

38.全量用什么工具，增量用什么工具 

答：全量：XtraBackup 增量：mysqldump 1.写脚本每天晚上0点，定时将B服务器数据备份到A，并把备份结果发给运维









# 面试考题

## A卷
1、如何实现 Nginx 代理的节点访问日志记录客户的 IP 而不是代理的 IP？ 
2、/var/log/messages 日志出现 kernel: nf_conntrack: table full, dropping packet.请问是什么原因 
导致的？如何解决？ 
3、linux 系统 nginx php 环境，发现 PHP-FPM 进程占用 CPU 高，请问可能的原因，以及如何解决? 
4、一主多从，主库宕机，如何切换到从库，其他的从库如何处理？ 
5、误操作 drop 语句导致数据破坏，请给出恢复思想及实际步骤。 
6、请举一个生产中实际的例子网站打开慢由于数据库慢导致的。 
7、通过 kill -9 野蛮粗鲁杀死数据库导致数据库启动故障，给出排除方法或者经验。 
8、IDC 机房带宽突然从平时 100M 增加到 400M，请你分析问题所在，并解决。 
9、正在工作的 linux，发现文件系统只读了，你觉得导致问题的原因是什么，如何解决？ 
10、磁盘报错“No space left on device”，但是 df -h 查看磁盘空间没满，请问为什么？ 
11、磁盘空间满了，删除了一部分 nginx access 日志，但是，发现磁盘空间还是满的，请问为什么？更改当前 apache 日志的 access.log 为 www.log，请问程序写新日志会写到 www.log 么？ 
12、写一个 tomcat 启动脚本，手工 OK，但是放入定时任务就是不执行，请问为什么？ 
13、请利用 shell 开发一个 rsync 服务的启动停止脚本并通过 chkconfig 进行开关机管理。 
14、请利用 shell 开发监控 MySQL 主从同步及是否延迟的插件，并给出通过 nagios 主动和 
被动实际实战配置步骤。 
15、请详细描述 LVS DR 模式的原理以及 keepalived 高可用服务工作原理？ 
16、请详细描述 MySQL 主从复制原理，nginx fastcgi 工作原理。 
17、请描述 raid 0 1 5 10 的原理、相关特点 ，性能区别，集群中各角色如何选择 RAID。 
18、apache 服务的常用工作模式及对应特点，企业如何选择对应模式。


## B卷
1、如何通过 linux 实现一个局域网或者 IDC 机房上网网关，请给出步骤及命令？ 
2、192.168.0.0/24 网段通过 192.168.0.1 网关连入 172.16.1.0/24 ip 段,如何添加路由？ 
3、使用非交互式命令语言把文件从 A 服务器推送到 B,C 服务器，请写出脚本。已知 A,B,C 服务器的密码为 root 密码 123456， 端口为 22（禁止用 ssh key 密钥功能）。 
4、用户访问 jd.com 网站集群架构很慢，如果你是 jd 的运维人员，请详细分析可能的原因,及排查方法？ 
5、公司机房的服务器接近 254 台了， 请你设计一个解决方案，如何划分网络，并实现业务平滑迁移。 
6、nginx 代理上如何实现代理 RS 集群节点上的不同虚拟主机，请给出配置，方法，或思路。 
7、请开发插件实现监控网站站点目录的文件及内容变更，并加入到 nagios 监控管理，给出实现插件代码及部署详细步骤？ 
8、请描述 DNS 解析的原理详细过程？ s
10、请描述 OSI7 层模型各层名字及功能，并举例在不同层对应的协议。 
11、描述 tcp/ip 3 次握手及 4 次断开工作原理过程。 
12、请说出 netstat -an 命令结果中最后一列 status 对应的不同网络连接状态含义，以及如何调整优化这些网络连接细节。 
13、工作中都遇到过那些运维故障，如何解决的，请描述 2 个你发现并解决的故障案例。 
14、binlog 是什么？binlog 记录的是什么？有几种模式及优缺点，企业中如何选择做同步？ 
15、请详细描述 http 协议工作原理。 
16、请详细描述 MySQL 主从复制原理。 
17、当 MySQL 误删数据时如何恢复(请分析所有你能想到的故障环境)。 
18、MySQL 主从复制故障机延迟原因有哪些，工作中你是如何解决的？



## C卷
1、如何能把/mnt/test.txt 拷贝到/tmp 不提示的覆盖掉已有的 test.txt 文件。 
2、只查看 abc.txt 文件（共 100 行）内第 20 到第 30 行的内容。 
3、请执行命令取出 linux 中 eth0或者ens33 的 IP 地址。 
4、每周日上午 9：30 定时备份mysql数据库（用脚本代替），请给出完整配置过程。 
5、请给出 10 个 vi/vim 编辑器常用操作命令包括快捷键 
6、写个定时任务删除 7 天前访问日志。 
7、/etc/fstab 文件最后两列的数字分别表示什么意思？ 
8、R720 1T 的硬盘 6 块做好 RAID5,请问如何安装 Centos 系统并按如下方式分区。 /boot 200m，/ 100G，swap 16G ，/data 剩余 
9、请写出以下端口对应的服务？ 端口：21 22 25 3306 873 161 111 3389 80 443 110 
10、如果主机无法连接网络，请给出你的详细的排查思路？ 
11、批量随机创建 10 个以 html 结尾的文件 
12、请再上面每个文件名的结尾增加 abc 字符串（扩展名前） 
13、批量创建 10 个用户，设置随机 8 位密码。 
14、请描述 http 状态码的含义，并举一个你在企业中发生的案例。 状态码：301 403 404 500 502 503 504 
15、请开发脚本定时分析 access.log 日志或网络连接数，PV 大于 100 的访问，封掉对应 IP。 
16、请详细描述 netstat 网络连接状态的不同含义，以及如何针对每个状态进行优化？ 
17、如何实现 web 图片防盗？给出防盗原理及大概配置步骤。 
18、请问你的网站主营业务是什么，并发量，日 PV,IP 量分别是多少？ 
19、请随意写一个你工作中完成任务最得意的 SHELL 脚本的例子。 

## D卷
1、请详细 Linux 系统从开机到登陆界面的启动过程？ 
2、如何优化 linux 系统（不仅仅是常规优化）？ 
3、请详细描述 linux 下软链接和硬链接的区别？ 
4、请详细描述 linux 下文件删除的原理？ 
5、详细描述磁盘读写数据原理，分区方式，文件系统 
6、linux root 密码忘了,如何找回来？ 
7、/etc/fstab 文件的作用，如果因为配错 fstab 导致开机无法启动了，如何解决？ 
8、MySQL 密码忘了,如何找回来，如果是多实例数据库，又如何找回？ 
9、MySQL 常用引擎有哪些及特点区别，工作中如何选择引擎。 
10、请设计一个你认为高大上的 MySQL 备份方案？ 
11、企业大并发场景如何优化 MySQL 数据库，请细致描述？ 
12、给你无限带宽以及无限服务器资源，请设计一个架构防止大规模 DDOS,CC 攻击？ 
13、如何优化 apache 以及 nginx 服务？ 
14、网站被上传木马到附件目录，在所有文件插入了代码，请问如何解决，如何预防？ 
15、Memcached 服务内存管理机制工作原理？ 
16、Memcached 服务分布式集群如何实现？一致性哈希算法作用及原理描述？ 
17、Memcached 与 redis 相同点和区别？ 
18、如何更改已有数据的 MySQL 数据库的字符集，给出实施步骤？ 
19、请描述你理解的，运维工作都做什么？ 
20、批量创建 10个用户stu01-stu10，并且设置随机8 位密码，要求：不能用 shell 循环（例如：for,while 等），只能用 linux 命令及管道实现。 